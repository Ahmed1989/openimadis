/**
 * openImaDis - Open Image Discovery: Image Life Cycle Management Software
 * Copyright (C) 2011-2016  Strand Life Sciences
 *   
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package com.strandgenomics.imaging.iengine.system;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Date;
import java.util.List;
import java.util.TreeSet;
import java.util.logging.Level;

import com.strandgenomics.imaging.icore.Constants;
import com.strandgenomics.imaging.icore.db.DataAccessException;
import com.strandgenomics.imaging.icore.system.ErrorCode;
import com.strandgenomics.imaging.icore.util.Util;
import com.strandgenomics.imaging.iengine.ImagingEngineException;

/**
 * handles searching/accessing system logs generated by iengine, worker and
 * bioformats
 * 
 * @author Anup Kulkarni
 */
public class LogSearchManager extends SystemManager {

	/**
	 * date format used for storing engine logs 
	 */
	private SimpleDateFormat engineFormat;
	
	/**
	 * date format used for storing bio-formats logs
	 */
	private SimpleDateFormat lociFormat;
	
	LogSearchManager() 
	{
		engineFormat = new SimpleDateFormat("yyyy_MM_dd");
		lociFormat = new SimpleDateFormat("yyyy-MM-dd");
	}
	
	/**
	 * returns list of logfile paths for given date with given offset and limit
	 * @param user logged in user 
	 * @param date (can be null, in which case all log files are returned)
	 * @param start start index
	 * @param limit number of entries to be returned
	 * @return
	 * @throws DataAccessException
	 */
	public List<String> getLogFiles(String user, Date date, int start, int limit)
	{
		if(!SysManagerFactory.getUserPermissionManager().isAdministrator(user))
			throw new ImagingEngineException(new ErrorCode(ErrorCode.ImageSpace.UNAUTHORIZED_ACCESS));
		
		List<String> filesForDate = getLogFiles(user, date);
		int end = start + limit;
		if(end>=filesForDate.size())
			end = filesForDate.size();
		
		return filesForDate.subList(start, end);
	}
	
	/**
	 * returns list of logfile paths for given date
	 * @param actor logged in user 
	 * @param date (can be null, in which case all log files are returned)
	 * @return list of logfile paths for given date
	 * @throws DataAccessException 
	 */
	public List<String> getLogFiles(String actor, Date date)
	{
		if(!SysManagerFactory.getUserPermissionManager().isAdministrator(actor))
			throw new ImagingEngineException(new ErrorCode(ErrorCode.ImageSpace.UNAUTHORIZED_ACCESS));
		
		File logDirectory = Constants.getLogDirectory();
		File[] files = logDirectory.listFiles();
		
		List<String> filenames = new ArrayList<String>();
		if(files == null)
			return filenames;
		
		List<File>filesForDate = getFilesForDate(files, date);
		for(File f:filesForDate)
		{
			filenames.add(f.getName());
		}
		
		return filenames;
	}
	
	/**
	 * send the file on the specified outputstream
	 * @param actorLogin logged in user
	 * @param outputStream
	 * @param logfileName
	 * @throws IOException
	 */
	public void acceptRequest(String actorLogin, OutputStream outputStream, String logfileName) throws IOException
	{
		File logDirectory = Constants.getLogDirectory();
		
		if(!SysManagerFactory.getUserPermissionManager().isFacilityManager(actorLogin))
			throw new ImagingEngineException(new ErrorCode(ErrorCode.ImageSpace.UNAUTHORIZED_ACCESS));
		
		File file = new File(logDirectory, logfileName);
		if(!file.getCanonicalFile().getParentFile().equals(logDirectory))
			throw new ImagingEngineException(new ErrorCode(ErrorCode.ImageSpace.NOT_VALID_FILEPATH));
		
		sendFile(outputStream, file);
	}
	
	private void sendFile(OutputStream response, File file) throws IOException
	{
		BufferedOutputStream oStream = null;
		
		FileInputStream fStream = null;
		BufferedInputStream iStream = null;

		try
		{
			oStream = new BufferedOutputStream(response);
			logger.logp(Level.INFO, "DataExchangeServlet", "sendFile", "sending data "+file +" of length "+file.length());
			
			fStream = new FileInputStream(file);
			iStream = new BufferedInputStream(fStream);

			long dataLength = Util.transferData(iStream, oStream);
			logger.logp(Level.INFO, "DataExchangeServlet", "sendFile", "successfully send file " + dataLength);
		} 
		catch (IOException ex) 
		{
			throw ex;
		} 
		finally
		{
			Util.closeStream(oStream);
			Util.closeStream(fStream);
			Util.closeStream(iStream);
		}
	}

	/**
	 * return the log file
	 * @param actor logged in user
	 * @param filename name of the log file
	 * @return the specified log file
	 * @throws IOException 
	 */
	public File getLogFile(String actor, String filename)
	{
		if(!SysManagerFactory.getUserPermissionManager().isAdministrator(actor))
			throw new ImagingEngineException(new ErrorCode(ErrorCode.ImageSpace.UNAUTHORIZED_ACCESS));
		
		File logDirectory = Constants.getLogDirectory();
		
		File file = new File(logDirectory, filename);
		try
		{
			if(!file.getCanonicalFile().getParentFile().equals(logDirectory))
				throw new ImagingEngineException(new ErrorCode(ErrorCode.ImageSpace.NOT_VALID_FILEPATH));
			return file;
		}
		catch (IOException e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return null;
	}

	private List<File> getFilesForDate(File[] files, Date date)
	{
		List<File> fileList = Arrays.asList(files);
		
		TreeSet<File> filtered = new TreeSet<File>(new Comparator<File>() {

			@Override
			public int compare(File o1, File o2)
			{
				if(o1.lastModified()>o2.lastModified())
					return 1;
				if(o1.lastModified()<o2.lastModified())
					return -1;
				
				return 0;
			}
		});
		
		if(files!=null)
		{
			if(date == null)
			{
				filtered.addAll(fileList);
				return new ArrayList<File>(filtered);
			}
			
			for(File file : files)
			{
				if (file.getName().contains(engineFormat.format(date)) || file.getName().contains(lociFormat.format(date)))
					filtered.add(file);
			}
		}
		
		return new ArrayList<File>(filtered);
	}
}
